import { BaileysClass } from '../lib/baileys.js';
const { getYoutubeVideoInfo, getYoutubeMP4, getYoutubeMP3, getYoutubeTrending, getRelatedVideos, getLyrics } = require('../lib/youtube.js'); // Adjust path as needed
const fs = require('fs');
const path = require('path');
const https = require('https');

const botBaileys = new BaileysClass({});

botBaileys.on('auth_failure', async (error) => console.log("ERROR BOT: ", error));
botBaileys.on('qr', (qr) => console.log("NEW QR CODE: ", qr));
botBaileys.on('ready', async () => console.log('READY BOT'));

// Enhanced user session management
const userSessions = new Map();

// Helper function to get or create user session
const getUserSession = (userId) => {
    if (!userSessions.has(userId)) {
        userSessions.set(userId, {
            awaitingResponse: false,
            awaitingYouTubeQuery: false,
            awaitingDownloadChoice: false,
            awaitingLyricsQuery: false,
            pendingVideoInfo: null,
            pendingRelatedVideos: null,
            lastActivity: Date.now()
        });
    }
    return userSessions.get(userId);
};

// Clean up inactive sessions (older than 10 minutes)
setInterval(() => {
    const now = Date.now();
    for (const [userId, session] of userSessions.entries()) {
        if (now - session.lastActivity > 600000) { // 10 minutes
            userSessions.delete(userId);
        }
    }
}, 300000); // Check every 5 minutes

// Helper function to create temporary file path
const createTempFilePath = (extension) => {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(7);
    return path.join(__dirname, 'temp', `${timestamp}_${random}.${extension}`);
};

// Ensure temp directory exists
const tempDir = path.join(__dirname, 'temp');
if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
}

// Helper function to clean up temporary files
const cleanupTempFile = (filePath) => {
    setTimeout(() => {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
        }
    }, 5000); // Delete after 5 seconds
};

// Helper function to download image from URL
const downloadImage = (url, filepath) => {
    return new Promise((resolve, reject) => {
        const file = fs.createWriteStream(filepath);
        https.get(url, (response) => {
            response.pipe(file);
            file.on('finish', () => {
                file.close();
                resolve(filepath);
            });
        }).on('error', (err) => {
            fs.unlink(filepath, () => {});
            reject(err);
        });
    });
};

botBaileys.on('message', async (message) => {
    const session = getUserSession(message.from);
    session.lastActivity = Date.now();

    try {
        // Handle lyrics query input
        if (session.awaitingLyricsQuery) {
            await handleLyricsSearch(message, session);
            return;
        }

        // Handle YouTube query input
        if (session.awaitingYouTubeQuery) {
            await handleYouTubeSearch(message, session);
            return;
        }

        // Handle download choice
        if (session.awaitingDownloadChoice && session.pendingVideoInfo) {
            await handleDownloadChoice(message, session);
            return;
        }

        // Handle initial menu
        if (!session.awaitingResponse) {
            await botBaileys.sendPoll(message.from, 'ü§ñ Select an option', {
                options: [
                    'üí¨ Text', 
                    'üì∑ Media', 
                    'üìÑ File', 
                    'üé≠ Sticker', 
                    'üéµ YouTube Audio', 
                    'üé¨ YouTube Video', 
                    'üîç YouTube Search',
                    'üé§ Song Lyrics',
                    'üî• Trending Music',
                    'üñºÔ∏è Thumbnail Extract'
                ],
            });
            session.awaitingResponse = true;
            return;
        }

        // Handle menu selections
        const command = message.body.toLowerCase().trim();
        await handleMenuCommand(message, session, command);

    } catch (error) {
        console.error('Error processing message:', error);
        await botBaileys.sendText(message.from, '‚ùå An error occurred. Please try again.');
        resetUserSession(session);
    }
});

// Handle lyrics search
const handleLyricsSearch = async (message, session) => {
    const query = message.body.trim();
    
    if (query.toLowerCase() === 'cancel') {
        await botBaileys.sendText(message.from, '‚ùå Lyrics search cancelled.');
        resetUserSession(session);
        return;
    }

    await botBaileys.sendText(message.from, 'üé§ Searching for lyrics...');

    try {
        const lyricsResult = await getLyrics(query);
        
        if (lyricsResult.error) {
            await botBaileys.sendText(message.from, `‚ùå ${lyricsResult.error}`);
            resetUserSession(session);
            return;
        }

        const lyrics = lyricsResult.result;
        
        // Note: We don't send full lyrics due to copyright restrictions
        // Instead, we provide song information and a snippet
        const lyricsInfo = `
üé§ *Song Found*

üéµ *Title:* ${lyrics.title}
üë®‚Äçüé§ *Artist:* ${lyrics.artist}
üíø *Album:* ${lyrics.album || 'Unknown'}

üìù *Lyrics Preview:*
${lyrics.lyrics ? lyrics.lyrics.substring(0, 200) + '...' : 'Lyrics not available'}

‚ö†Ô∏è *Note:* Full lyrics are not provided due to copyright restrictions. Please visit the official music platforms or lyrics websites for complete lyrics.`;

        await botBaileys.sendText(message.from, lyricsInfo);
        
        // If thumbnail is available, send it
        if (lyrics.thumbnail) {
            try {
                const thumbnailPath = createTempFilePath('jpg');
                await downloadImage(lyrics.thumbnail, thumbnailPath);
                await botBaileys.sendMedia(message.from, thumbnailPath, 'üñºÔ∏è Song Thumbnail');
                cleanupTempFile(thumbnailPath);
            } catch (error) {
                console.error('Error downloading thumbnail:', error);
            }
        }

    } catch (error) {
        console.error('Lyrics search error:', error);
        await botBaileys.sendText(message.from, '‚ùå Error searching for lyrics. Please try again.');
    }
    
    resetUserSession(session);
};

// Handle YouTube search
const handleYouTubeSearch = async (message, session) => {
    const query = message.body.trim();
    
    if (query.toLowerCase() === 'cancel') {
        await botBaileys.sendText(message.from, '‚ùå YouTube search cancelled.');
        resetUserSession(session);
        return;
    }

    await botBaileys.sendText(message.from, 'üîç Searching YouTube...');

    try {
        const videoInfo = await getYoutubeVideoInfo(query);
        
        if (videoInfo.error) {
            await botBaileys.sendText(message.from, `‚ùå ${videoInfo.error}`);
            resetUserSession(session);
            return;
        }

        const info = videoInfo.result;
        const infoText = `
üé¨ *YouTube Video Found*

üìù *Title:* ${info.title}
‚è±Ô∏è *Duration:* ${info.durationFormatted}
üì∫ *Channel:* ${info.channelId}
üëÄ *Views:* ${info.viewCount ? info.viewCount.toLocaleString() : 'N/A'}
üëç *Likes:* ${info.likeCount ? info.likeCount.toLocaleString() : 'N/A'}
üÜî *Video ID:* ${info.videoId}

üìù *Description:*
${info.shortDescription.substring(0, 200)}${info.shortDescription.length > 200 ? '...' : ''}

What would you like to do?`;

        await botBaileys.sendText(message.from, infoText);
        
        // Send thumbnail if available
        if (info.thumbnail) {
            try {
                const thumbnailPath = createTempFilePath('jpg');
                await downloadImage(info.thumbnail, thumbnailPath);
                await botBaileys.sendMedia(message.from, thumbnailPath, 'üñºÔ∏è Video Thumbnail');
                cleanupTempFile(thumbnailPath);
            } catch (error) {
                console.error('Error downloading thumbnail:', error);
            }
        }

        await botBaileys.sendPoll(message.from, 'Choose an option:', {
            options: [
                'üéµ Download Audio (MP3)', 
                'üé¨ Download Video (MP4)', 
                'üîó Related Videos',
                'üñºÔ∏è Extract Thumbnail',
                '‚ùå Cancel'
            ]
        });

        session.awaitingYouTubeQuery = false;
        session.awaitingDownloadChoice = true;
        session.pendingVideoInfo = info;

        // Get related videos in background
        try {
            const relatedVideos = await getRelatedVideos(info.videoId);
            session.pendingRelatedVideos = relatedVideos.result || [];
        } catch (error) {
            console.error('Error getting related videos:', error);
            session.pendingRelatedVideos = [];
        }

    } catch (error) {
        console.error('YouTube search error:', error);
        await botBaileys.sendText(message.from, '‚ùå Error searching YouTube. Please try again.');
        resetUserSession(session);
    }
};

// Handle download choice
const handleDownloadChoice = async (message, session) => {
    const choice = message.body.toLowerCase().trim();
    
    if (choice.includes('cancel')) {
        await botBaileys.sendText(message.from, '‚ùå Operation cancelled.');
        resetUserSession(session);
        return;
    }

    const videoInfo = session.pendingVideoInfo;
    
    if (choice.includes('audio') || choice.includes('mp3')) {
        await downloadYouTubeAudio(message.from, videoInfo);
    } else if (choice.includes('video') || choice.includes('mp4')) {
        await downloadYouTubeVideo(message.from, videoInfo);
    } else if (choice.includes('related')) {
        await showRelatedVideos(message.from, session);
    } else if (choice.includes('thumbnail')) {
        await extractThumbnail(message.from, videoInfo);
    } else {
        await botBaileys.sendText(message.from, '‚ùå Invalid choice. Please select a valid option.');
        return;
    }
    
    resetUserSession(session);
};

// Show related videos
const showRelatedVideos = async (phoneNumber, session) => {
    try {
        if (!session.pendingRelatedVideos || session.pendingRelatedVideos.length === 0) {
            await botBaileys.sendText(phoneNumber, '‚ùå No related videos found.');
            return;
        }

        let relatedText = 'üîó *Related Videos:*\n\n';
        
        session.pendingRelatedVideos.slice(0, 5).forEach((video, index) => {
            relatedText += `${index + 1}. *${video.title}*\n`;
            relatedText += `   üì∫ ${video.channelTitle}\n`;
            relatedText += `   ‚è±Ô∏è ${video.duration || 'N/A'}\n`;
            relatedText += `   üëÄ ${video.viewCount ? video.viewCount.toLocaleString() : 'N/A'} views\n`;
            relatedText += `   üîó https://youtu.be/${video.videoId}\n\n`;
        });

        await botBaileys.sendText(phoneNumber, relatedText);
        
    } catch (error) {
        console.error('Error showing related videos:', error);
        await botBaileys.sendText(phoneNumber, '‚ùå Error retrieving related videos.');
    }
};

// Extract thumbnail
const extractThumbnail = async (phoneNumber, videoInfo) => {
    try {
        await botBaileys.sendText(phoneNumber, 'üñºÔ∏è Extracting thumbnail...');
        
        if (!videoInfo.thumbnail) {
            await botBaileys.sendText(phoneNumber, '‚ùå No thumbnail available for this video.');
            return;
        }

        const thumbnailPath = createTempFilePath('jpg');
        await downloadImage(videoInfo.thumbnail, thumbnailPath);
        
        await botBaileys.sendMedia(phoneNumber, thumbnailPath, 
            `üñºÔ∏è *Thumbnail Extracted*\n\nüìù *Title:* ${videoInfo.title}\nüì∫ *Channel:* ${videoInfo.channelId}`
        );
        
        cleanupTempFile(thumbnailPath);
        
    } catch (error) {
        console.error('Thumbnail extraction error:', error);
        await botBaileys.sendText(phoneNumber, '‚ùå Error extracting thumbnail. Please try again.');
    }
};

// Get trending music
const getTrendingMusic = async (phoneNumber) => {
    try {
        await botBaileys.sendText(phoneNumber, 'üî• Getting trending music...');
        
        const trendingResult = await getYoutubeTrending('music');
        
        if (trendingResult.error) {
            await botBaileys.sendText(phoneNumber, `‚ùå ${trendingResult.error}`);
            return;
        }

        const trending = trendingResult.result;
        let trendingText = 'üî• *Trending Music:*\n\n';
        
        trending.slice(0, 10).forEach((video, index) => {
            trendingText += `${index + 1}. *${video.title}*\n`;
            trendingText += `   üë®‚Äçüé§ ${video.channelTitle}\n`;
            trendingText += `   üëÄ ${video.viewCount ? video.viewCount.toLocaleString() : 'N/A'} views\n`;
            trendingText += `   üîó https://youtu.be/${video.videoId}\n\n`;
        });

        await botBaileys.sendText(phoneNumber, trendingText);
        
    } catch (error) {
        console.error('Trending music error:', error);
        await botBaileys.sendText(phoneNumber, '‚ùå Error getting trending music. Please try again.');
    }
};

// Download YouTube audio
const downloadYouTubeAudio = async (phoneNumber, videoInfo) => {
    try {
        await botBaileys.sendText(phoneNumber, 'üéµ Downloading audio... Please wait.');
        
        const audioResult = await getYoutubeMP3(`https://www.youtube.com/watch?v=${videoInfo.videoId}`);
        
        if (audioResult.error) {
            await botBaileys.sendText(phoneNumber, `‚ùå Error downloading audio: ${audioResult.error}`);
            return;
        }

        // Save audio buffer to temporary file
        const tempFilePath = createTempFilePath('mp3');
        fs.writeFileSync(tempFilePath, audioResult.result);
        
        // Send audio file
        await botBaileys.sendAudio(phoneNumber, tempFilePath);
        await botBaileys.sendText(phoneNumber, `üéµ *${videoInfo.title}*\n‚úÖ Audio downloaded successfully!`);
        
        // Cleanup
        cleanupTempFile(tempFilePath);
        
    } catch (error) {
        console.error('Audio download error:', error);
        await botBaileys.sendText(phoneNumber, '‚ùå Error downloading audio. Please try again.');
    }
};

// Download YouTube video
const downloadYouTubeVideo = async (phoneNumber, videoInfo) => {
    try {
        await botBaileys.sendText(phoneNumber, 'üé¨ Downloading video... Please wait (this may take a while).');
        
        // Show progress updates
        const progressCallback = (progress) => {
            console.log(`Download progress: ${progress}`);
        };
        
        const videoResult = await getYoutubeMP4(`https://www.youtube.com/watch?v=${videoInfo.videoId}`, progressCallback);
        
        if (videoResult.error) {
            await botBaileys.sendText(phoneNumber, `‚ùå Error downloading video: ${videoResult.error}`);
            return;
        }

        // Save video buffer to temporary file
        const tempFilePath = createTempFilePath('mp4');
        fs.writeFileSync(tempFilePath, videoResult.result);
        
        // Check file size (WhatsApp has limits)
        const fileSizeMB = fs.statSync(tempFilePath).size / (1024 * 1024);
        
        if (fileSizeMB > 64) { // WhatsApp video limit is ~64MB
            await botBaileys.sendText(phoneNumber, 
                `‚ùå Video is too large (${fileSizeMB.toFixed(1)}MB). WhatsApp limit is 64MB.\n\n` +
                `üéµ Would you like to download as audio instead?`
            );
            cleanupTempFile(tempFilePath);
            return;
        }
        
        // Send video file
        await botBaileys.sendVideo(phoneNumber, tempFilePath, `üé¨ *${videoInfo.title}*\n‚úÖ Video downloaded successfully!`);
        
        // Cleanup
        cleanupTempFile(tempFilePath);
        
    } catch (error) {
        console.error('Video download error:', error);
        await botBaileys.sendText(phoneNumber, '‚ùå Error downloading video. Please try again.');
    }
};

// Handle menu commands
const handleMenuCommand = async (message, session, command) => {
    switch (command) {
        case 'text':
        case 'üí¨ text':
            await botBaileys.sendText(message.from, 'Hello world! üëã');
            break;
            
        case 'media':
        case 'üì∑ media':
            await botBaileys.sendMedia(message.from, 'https://www.w3schools.com/w3css/img_lights.jpg', 'Hello world! üì∑');
            break;
            
        case 'file':
        case 'üìÑ file':
            await botBaileys.sendFile(message.from, 'https://github.com/pedrazadixon/sample-files/raw/main/sample_pdf.pdf');
            break;
            
        case 'sticker':
        case 'üé≠ sticker':
            await botBaileys.sendSticker(message.from, 'https://gifimgs.com/animations/anime/dragon-ball-z/Goku/goku_34.gif', { pack: 'User', author: 'Me' });
            break;
            
        case 'youtube audio':
        case 'üéµ youtube audio':
            await botBaileys.sendText(message.from, 
                'üéµ *YouTube Audio Downloader*\n\n' +
                'Send me:\n' +
                '‚Ä¢ YouTube URL\n' +
                '‚Ä¢ Video title to search\n' +
                '‚Ä¢ Artist name and song\n\n' +
                'Type "cancel" to abort.'
            );
            session.awaitingYouTubeQuery = true;
            session.awaitingResponse = false;
            break;
            
        case 'youtube video':
        case 'üé¨ youtube video':
            await botBaileys.sendText(message.from, 
                'üé¨ *YouTube Video Downloader*\n\n' +
                'Send me:\n' +
                '‚Ä¢ YouTube URL\n' +
                '‚Ä¢ Video title to search\n\n' +
                '‚ö†Ô∏è *Note:* Videos larger than 64MB cannot be sent via WhatsApp.\n\n' +
                'Type "cancel" to abort.'
            );
            session.awaitingYouTubeQuery = true;
            session.awaitingResponse = false;
            break;
            
        case 'youtube search':
        case 'üîç youtube search':
            await botBaileys.sendText(message.from, 
                'üîç *YouTube Search*\n\n' +
                'Send me any search term and I\'ll find videos for you!\n\n' +
                'Examples:\n' +
                '‚Ä¢ "Imagine Dragons Bones"\n' +
                '‚Ä¢ "How to cook pasta"\n' +
                '‚Ä¢ "JavaScript tutorial"\n\n' +
                'Type "cancel" to abort.'
            );
            session.awaitingYouTubeQuery = true;
            session.awaitingResponse = false;
            break;
            
        case 'song lyrics':
        case 'üé§ song lyrics':
            await botBaileys.sendText(message.from, 
                'üé§ *Song Lyrics Search*\n\n' +
                'Send me:\n' +
                '‚Ä¢ Song title and artist\n' +
                '‚Ä¢ Just the song title\n' +
                '‚Ä¢ Part of the lyrics\n\n' +
                'Examples:\n' +
                '‚Ä¢ "Imagine Dragons Bones"\n' +
                '‚Ä¢ "Shape of You Ed Sheeran"\n' +
                '‚Ä¢ "Hello Adele"\n\n' +
                '‚ö†Ô∏è *Note:* Only song information and preview will be provided due to copyright restrictions.\n\n' +
                'Type "cancel" to abort.'
            );
            session.awaitingLyricsQuery = true;
            session.awaitingResponse = false;
            break;
            
        case 'trending music':
        case 'üî• trending music':
            await getTrendingMusic(message.from);
            break;
            
        case 'thumbnail extract':
        case 'üñºÔ∏è thumbnail extract':
            await botBaileys.sendText(message.from, 
                'üñºÔ∏è *Thumbnail Extractor*\n\n' +
                'Send me:\n' +
                '‚Ä¢ YouTube URL\n' +
                '‚Ä¢ Video title to search\n\n' +
                'I\'ll extract the high-quality thumbnail for you!\n\n' +
                'Type "cancel" to abort.'
            );
            session.awaitingYouTubeQuery = true;
            session.awaitingResponse = false;
            break;
            
        default:
            await botBaileys.sendText(message.from, 
                '‚ùå Sorry, I didn\'t understand that command.\n\n' +
                'üîÑ Please select an option from the poll menu.'
            );
            break;
    }
    
    // Reset session for completed commands (except YouTube and lyrics ones)
    if (!session.awaitingYouTubeQuery && !session.awaitingLyricsQuery) {
        resetUserSession(session);
    }
};

// Reset user session
const resetUserSession = (session) => {
    session.awaitingResponse = false;
    session.awaitingYouTubeQuery = false;
    session.awaitingDownloadChoice = false;
    session.awaitingLyricsQuery = false;
    session.pendingVideoInfo = null;
    session.pendingRelatedVideos = null;
};
